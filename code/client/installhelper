#!/usr/local/munki/munki-python
# encoding: utf-8
#
# Copyright 2011-2024 Greg Neagle.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
installhelper

Created 2024-02-20.

A helper tool for handling launchd items etc when installing Munki

"""
from __future__ import absolute_import

# standard libs
import glob
import os
import subprocess
import time
import sys

# our libs
from munkilib import munkilog
from munkilib import osutils
from munkilib import prefs
from munkilib import FoundationPlist


CHECK_TIME = '10'
LAUNCHD_PREFIX = 'com.googlecode.munki.'
PROCESS_ID = 'com.googlecode.munki.installhelper'
PROG_NAME = 'managedsoftwareupdate'
VERSION = '0.1'


def main():
    '''Main function'''

    # check to see if we're root
    if os.geteuid() != 0:
        print('You must run this as root!', file=sys.stderr)
        sys.exit(1)

    # Add munki's path to import munki's modules
    sys.path.append("/usr/local/munki")

    if prefs.pref('LogToSyslog'):
        munkilog.configure_syslog()

    log('v%s launched' % VERSION)

    # only proceed if PROG_NAME isn't running, looping until it's not running
    is_managedsoftwareupdate_running()

    # returns a list of launch daemons prefixed with LAUNCHD_PREFIX
    launch_daemons = glob.glob("/Library/LaunchDaemons/" + LAUNCHD_PREFIX + "*")

    # reload launch daemons as needed
    reload_launch_daemons(launch_daemons)

    # returns a list of launch agents prefixed with LAUNCHD_PREFIX
    launch_agents = glob.glob("/Library/LaunchAgents/" + LAUNCHD_PREFIX + "*")

    # reload munki's loginwindow launch agents
    reload_loginwindow_launch_agents(launch_agents)

    # Get the userid and username of any logged in users
    user_details = get_logged_in_users()

    # reload launchagents as needed
    if user_details:
        # If users are logged in, reload the required launch agents as them
        reload_user_launch_agents(launch_agents, user_details)
    else:
        # Log that we've skipped the above as no one is logged in
        log('At the login window and no one is logged in')

    log('completed tasks, exiting')

    sys.exit(0)


def get_logged_in_users():
    '''Returns a dict containing any logged in users uid and username'''

    user_details = {}

    # Retrieve details of all running processes
    cmd = ['/bin/ps', '-axo', 'uid,login,args']
    cmd_out = subprocess.run(cmd, capture_output = True, check = False)
    # Split out the above output
    for some_process in cmd_out.stdout.decode().splitlines():
        # Retrieve details for users that are running loginwindow.app, excluding root
        if "loginwindow.app" in some_process.lower() and some_process.split()[0] != "0":
            # Capture the userid and username for all users running the loginwindow
            user_details[some_process.split()[0]] = some_process.split()[1]

    # Returns either an empty dict, or a dict with userid and usernames
    return user_details


def log(msg):
    '''Logs messages from this tool with an identifier'''

    munkilog.log('%s: %s' % (PROCESS_ID, msg))


def is_managedsoftwareupdate_running():
    '''If managedsoftwareupdate is running, check again in x seconds'''

    managedsoftwareupdate_pid = osutils.pythonScriptRunning(PROG_NAME)

    while managedsoftwareupdate_pid:
        # an instance of managedsoftwareupdate is running, so we need to try again later
        log('*' * 60)
        log('%s is running as pid %s.' % (PROCESS_ID, managedsoftwareupdate_pid))
        log('checking again in %s seconds' % CHECK_TIME)
        log('*' * 60)
        time.sleep(CHECK_TIME)

    # if managedsoftwareupdate is not running.. return from function to proceed
    log('%s is not running, proceeding...' % (PROG_NAME))


def reload_launch_daemons(launch_daemons):
    '''Reloads Munki's Launch Daemons'''

    # Retrieve all running launch daemons
    cmd = ['/bin/launchctl', 'list']
    cmd_out = subprocess.run(cmd, capture_output = True, check = False)
    launchd_labels = split_launchctl_list(cmd_out)
    # For each plist in /Library/LaunchDaemons/ prefixed with LAUNCHD_PREFIX
    for launch_daemon in launch_daemons:
        try:
            # Make sure content is valid, before proceeding to reload
            daemon_content = FoundationPlist.readPlist(launch_daemon)
        except FoundationPlist.NSPropertyListSerializationException:
            break
        # Get the Label
        daemon_label = daemon_content.get('Label')
        if daemon_label:
            # Check to see if the launch daemon is loaded, before stopping
            if daemon_label in launchd_labels:
                # Stop the launch daemon at the login window
                log("Stopping: %s" % launch_daemon)
                cmd = ['/bin/launchctl', 'bootout', 'system/' + daemon_label]
                subprocess.call(cmd)
            # Load the launch daemon at the login window
            log("Loading: %s" % launch_daemon)
            cmd = ['/bin/launchctl', 'bootstrap', 'system', launch_daemon]
            subprocess.call(cmd)


def reload_loginwindow_launch_agents(launch_agents):
    '''Reloads Munki's loginwindow Launch Agents'''

    # Log what we're upto
    log('Reloading Launch Daemons')

    # Retrieve all running launch agents at the login window
    cmd = ['/bin/launchctl', 'list']
    cmd_out = subprocess.run(cmd, capture_output = True, check = False)
    launchd_labels = split_launchctl_list(cmd_out)
    # For each plist in /Library/LaunchAgents/ prefixed with LAUNCHD_PREFIX
    for launch_agent in launch_agents:
        try:
            # Make sure content is valid, before proceeding to reload
            agent_content = FoundationPlist.readPlist(launch_agent)
        except FoundationPlist.NSPropertyListSerializationException:
            break
        if agent_content.get('LimitLoadToSessionType'):
            # If the launch agent includes LimitLoadToSessionType, and it contains LoginWindow
            if 'LoginWindow' in agent_content.get('LimitLoadToSessionType'):
                # If the launch agent is to be loaded at the login window, get the Label
                agent_label = agent_content.get('Label')
                if agent_label:
                    # Check to see if the launch agent is loaded, before stopping
                    if agent_label in launchd_labels:
                        # Stop the launch agent at the login window
                        log("Stopping: %s" % launch_agent)
                        cmd = ['/bin/launchctl', 'bootout', 'loginwindow/' + agent_label]
                        subprocess.call(cmd)
                    # Load the launch agent at the login window
                    log("Loading: %s" % launch_agent)
                    cmd = ['/bin/launchctl', 'bootstrap', 'loginwindow', launch_agent]
                    subprocess.call(cmd)


def reload_user_launch_agents(launch_agents, user_details):
    '''Reloads the Launch Agents as the logged in users'''

    # For each logged in user
    for userid, username in user_details.items():
        # Log who we're reloading the Launch Agents as
        log('Reloading Launch Agents for: %s' % username)
        # Retrieve all running launch agents for the user
        cmd = ['/bin/launchctl', 'asuser', str(userid), '/bin/launchctl', 'list']
        cmd_out = subprocess.run(cmd, capture_output = True, check = False)
        launchd_labels = split_launchctl_list(cmd_out)
        # For each plist in /Library/LaunchAgents/ prefixed with LAUNCHD_PREFIX
        for launch_agent in launch_agents:
            try:
                # Make sure content is valid, before proceeding to reload
                agent_content = FoundationPlist.readPlist(launch_agent)
            except FoundationPlist.NSPropertyListSerializationException:
                break
            # If the launch agent doesn't contain LimitLoadToSessionType or
            # LimitLoadToSessionType exists and it contains Aqua
            if (not agent_content.get('LimitLoadToSessionType') or 'Aqua' in
                agent_content.get('LimitLoadToSessionType')):
                # If the launch agent is to be loaded at the login window, get the Label
                agent_label = agent_content.get('Label')
                if agent_label:
                    # Check to see if the launch agent is loaded, before stopping
                    if agent_label in launchd_labels:
                        # Stop the launch agent
                        log("Stopping: %s" % launch_agent)
                        cmd = ['/bin/launchctl', 'asuser', str(userid), '/bin/launchctl', 'bootout',
                               'gui/' + str(userid) + '/' + agent_label]
                        subprocess.call(cmd)
                    # Load the launch agent
                    log("Loading: %s" % launch_agent)
                    cmd = ['/bin/launchctl', 'asuser', str(userid), '/bin/launchctl', 'bootstrap',
                           'gui/' + str(userid), launch_agent]
                    subprocess.call(cmd)


def split_launchctl_list(cmd_out):
    '''Takes launchctl list output and returns a list with just the labels'''

    launchd_labels = []

    # Strip cmd_out to just the labels of the running launch agents
    for launchd_item in cmd_out.stdout.decode().splitlines():
        launchd_labels.append(launchd_item.split('\t')[2])

    # Returns a list of launchd labels
    return launchd_labels


if __name__ == '__main__':
    main()
